#!/usr/bin/env python

import json
import sys
from enum import Enum
from typing import Dict, List

import boto3
import click
from rich.console import Console
from rich.markdown import Markdown

from botocore.config import Config
import sys

console = Console()

#
# Shell completion
#
# Run the following to generate a static completion file:
#     _BEDROCK_COMPLETE=zsh_source bedrock > ~/.bedrock-completion.zsh
#
# Then add the following to your ~/.zshrc:
#     source ~/.bedrock-completion.zsh
#


class ConversationRole(Enum):
    USER = "user"
    ASSISTANT = "assistant"

    def __str__(self):
        return self.value


class Model(Enum):
    CLAUDE3_SONNET = "anthropic.claude-3-sonnet-20240229-v1:0"
    CLAUDE3_HAIKU = "anthropic.claude-3-haiku-20240307-v1:0"


def available_models():
    return [x.name.lower() for x in Model]


def model_enum_from_input(value):
    try:
        return Model[value.upper()]
    except KeyError:
        raise click.BadParameter(
            f"Invalid value: {value}. Allowed values are: {available_models}"
        )


def model_choice():
    choices = [enum_member.name for enum_member in Model]
    choice_help = ", ".join([f"'{choice}'" for choice in choices])

    def choice_function(value):
        try:
            return Model[value.upper()]
        except KeyError:
            raise click.BadParameter(
                f"Invalid value: {value}. Allowed values are: {choice_help}"
            )

    return (
        click.Choice(choices, case_sensitive=False),
        choice_function,
    )


def add_message(
    messages: List[Dict[str, str]], role: ConversationRole, user_message: str
):
    messages.append({"role": str(role), "content": user_message})
    return messages


def invoke(bedrock, model: Model, messages: List[Dict[str, str]]):
    modelId = model.value
    body = json.dumps(
        {
            "messages": messages,
            "max_tokens": 2000,
            "temperature": 1,
            "top_k": 250,
            "top_p": 0.999,
            "stop_sequences": ["\n\nHuman:"],
            "anthropic_version": "bedrock-2023-05-31",
        }
    )

    with console.status("[bold green]Waiting for response..."):
        response = bedrock.invoke_model(modelId=modelId, body=body)
        body = json.loads(response["body"].read())
        response_message = body["content"][0]

        if response_message["type"] != "text":
            raise RuntimeError(
                "Unexpected response type to prompt: " + response_message["type"]
            )

        output = response_message["text"]

    return output


def formatted_print(text):
    console.print(Markdown(text))


@click.command()
@click.argument("args", nargs=-1)
@click.option("-r", "--region", help="The AWS region to use for requests")
@click.option(
    "-m",
    "--model",
    type=click.Choice(available_models(), case_sensitive=False),
    default="claude3_sonnet",
    help="The model to use for requests",
)
def main(args, region, model):
    model = model_enum_from_input(model)
    message_history = []

    config = Config()
    if region:
        config = Config(region_name=region)

    bedrock = boto3.client("bedrock-runtime", config=config)

    print(
        f"Hello! I am an AI assistant powered by Amazon Bedrock and using the model {model.value}. Enter 'quit' or 'exit' at any time to exit. How may I help you today?"
    )
    print("(You can clear existing context by starting a query with 'new>')")

    while True:
        print()
        if message_history == [] and not sys.stdin.isatty():
            user_input = sys.stdin.read()
            print(f"> {user_input}")
        elif message_history == [] and args:
            user_input = " ".join(args)
            print(f"> {user_input}")
        elif not sys.stdin.isatty():
            print(
                "Note that you can only do one-shot requests when providing input via stdin"
            )
            exit()
        else:
            user_input = input("> ")

        print()
        if user_input.lower() == "quit" or user_input.lower() == "exit":
            print("Goodbye!")
            sys.exit()
        if user_input.lower().startswith("new>"):
            message_history = []
            continue

        message_history = add_message(
            message_history, ConversationRole.USER, user_input
        )

        response = invoke(bedrock, model, message_history)
        formatted_print(response)
        message_history = add_message(
            message_history, ConversationRole.ASSISTANT, response
        )

        print()


if __name__ == "__main__":
    main()
